# -*- coding: utf-8 -*-
"""18th assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dkE34bh393IbqQUQ8wSBN93UUclpaN9Q
"""

#first solution
def merge_intervals(intervals):
    # Sort intervals based on start times
    intervals.sort(key=lambda x: x[0])

    # Create an empty result list
    merged = []

    # Iterate through sorted intervals
    for interval in intervals:
        # If result list is empty or current interval does not overlap with last interval
        if not merged or interval[0] > merged[-1][1]:
            merged.append(interval)
        else:
            # Update end time of last interval
            merged[-1][1] = max(merged[-1][1], interval[1])

    return merged

#second solution
def sortColors(nums):
    low, mid, high = 0, 0, len(nums) - 1

    while mid <= high:
        if nums[mid] == 0:
            nums[mid], nums[low] = nums[low], nums[mid]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1

# Test the function
nums1 = [2, 0, 2, 1, 1, 0]
sortColors(nums1)
print(nums1)
# Output: [0, 0, 1, 1, 2, 2]

nums2 = [2, 0, 1]
sortColors(nums2)
print(nums2)
# Output: [0, 1, 2]

#third solution
def firstBadVersion(n):
    left = 1
    right = n

    while left < right:
        mid = left + (right - left) // 2
        if isBadVersion(mid):
            right = mid
        else:
            left = mid + 1

    return left

#forth solution
def maximumGap(nums):
    if len(nums) < 2:
        return 0

    # Find the maximum element in the array
    max_num = max(nums)

    # Perform radix sort
    exp = 1
    n = len(nums)
    aux = [0] * n

    while max_num // exp > 0:
        count = [0] * 10

        for num in nums:
            count[(num // exp) % 10] += 1

        for i in range(1, 10):
            count[i] += count[i - 1]

        for i in range(n - 1, -1, -1):
            digit = (nums[i] // exp) % 10
            aux[count[digit] - 1] = nums[i]
            count[digit] -= 1

        nums[:] = aux[:]
        exp *= 10

    # Find the maximum difference
    max_diff = 0
    for i in range(1, len(nums)):
        max_diff = max(max_diff, nums[i] - nums[i - 1])

    return max_diff

#fifth solution
def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False

#sixth solution
def findMinArrowShots(points):
    if not points:
        return 0

    # Sort the array based on the end position of the balloons
    points.sort(key=lambda x: x[1])

    end = points[0][1]
    arrows = 1

    # Iterate over the balloons starting from the second balloon
    for i in range(1, len(points)):
        if points[i][0] > end:
            # Current balloon is not overlapping with previous balloons
            arrows += 1
            end = points[i][1]

    return arrows

#seventh solution
def lengthOfLIS(nums):
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n
    maxLen = 1

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j] and dp[i] <= dp[j]:
                dp[i] = dp[j] + 1
                maxLen = max(maxLen, dp[i])

    return maxLen

#eighth solution
def find132pattern(nums):
    n = len(nums)
    stack = []
    s3 = float('-inf')

    for i in range(n - 1, -1, -1):
        if nums[i] < s3:
            return True
        while stack and nums[i] > stack[-1]:
            s3 = max(s3, stack.pop())
        stack.append(nums[i])

    return False